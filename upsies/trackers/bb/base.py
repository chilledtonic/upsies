"""
Base class for :class:`~.bb.movie.MovieBbTrackerJobs` and
:class:`~.bb.series.SeriesBbTrackerJobs`
"""

import abc

from ... import jobs
from ...utils import cached_property, release, webdbs
from ..base import TrackerJobsBase

import logging  # isort:skip
_log = logging.getLogger(__name__)


class BbTrackerJobsBase(TrackerJobsBase):
    @cached_property
    def release_name(self):
        """:class:`~.release.ReleaseName` instance"""
        return release.ReleaseName(self.content_path)

    @cached_property
    def imdb(self):
        """:class:`~.webdbs.imdb.ImdbApi` instance"""
        return webdbs.imdb.ImdbApi()

    @cached_property
    def imdb_job(self):
        """:class:`~.jobs.webdb.SearchWebDbJob` instance"""
        return jobs.webdb.SearchWebDbJob(
            content_path=self.content_path,
            db=self.imdb,
            callbacks={'output': self.handle_imdb_id},
            **self.common_job_args,
        )

    def handle_imdb_id(self, id):
        """Called when we have an IMDb ID"""
        _log.debug('Ignoring IMDB ID: %r', id)

    @property
    @abc.abstractmethod
    def torrent_filepath(self):
        """Path to torrent file from :attr:`create_torrent_job`"""

    @property
    @abc.abstractmethod
    def post_data(self):
        """POST request data that contains all the metadata generated by jobs"""

    def make_choices_job(self, name, label, autodetect_value, options):
        """
        Return :class:`~.jobs.dialog.ChoiceJob` instance

        :param name: See :class:`~.jobs.dialog.ChoiceJob`
        :param label: See :class:`~.jobs.dialog.ChoiceJob`
        :param autodetect_value: Autodetected choice
        :param options: Sequence of `(label, value, regex)` tuples. `label` is
            presented to the user and `value` is available via
            :attr:`~.jobs.dialog.ChoiceJob.choice` when this job is
            finished. The first `regex` that matches `autodetect_value` is
            visually marked as "auto-detected" for the user.
        """
        focused = None
        choices = []
        for choice, value, regex in options:
            if not focused and regex.search(autodetect_value):
                choices.append((f'{choice} (auto-detected)', value))
                focused = choices[-1]
            else:
                choices.append((choice, value))

        return jobs.dialog.ChoiceJob(
            name=name,
            label=label,
            choices=choices,
            focused=focused,
            **self.common_job_args,
        )
